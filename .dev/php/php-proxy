#!/usr/bin/env php
<?php /** @noinspection PhpUnused */
declare(strict_types=1);

// Defined in the Docker Image and set in the container
define("WORKING_DIR", getenv("WORKING_DIR"));

// Defined during Command execution, per Project, from the host
define("PROJECT_DIR", str_replace("/", "\\", getenv("PROJECT_DIR")));
define("CURRENT_DIR", str_replace("/", "\\", getenv("CURRENT_DIR")));

#require_once WORKING_DIR."/vendor/autoload.php";

#use UCRM\Plugins\Support\FileSystem;

// Shift the script (__FILE__) from the args, as we are handing off to the actual PHP interpreter.
$file = array_shift($argv);

$command = array_shift($argv);
$prefix = [];
$suffix = [];

switch($command)
{
    case "bash":
        // bash specific
        break;
    case "composer":
        $prefix = [ "--ansi" ];
        break;
    case "php":
        // php specific
        break;
    case "robo":
        $prefix = [ "--ansi" ];
        $roboFile = win2php(CURRENT_DIR."/RoboFile.php");
        if (file_exists($roboFile))
            $prefix[] = "--load-from $roboFile";
        break;
    default:
        // Anything else...
        //die("Command not yet implemented!");
        break;
}


// Loop through each argument and perform various fix-ups...
for ($i = 0; $i < count($argv); $i++)
{
    $arg = &$argv[$i];

    if ($arg === "-r" && ($i + 1) < count($argv))
    {
        $next = &$argv[$i + 1];
        $next = "\"".str_replace("\"", "\\\"", $next)."\"";
        $i++;
    }

    // IF the argument contains a \ or / at any position...
    if (strpos($arg, "\\") !== FALSE || strpos($arg, "/") !== FALSE)
    {
        $paths = [];

        //$paths[] = FileSystem::canonical($arg, "\\");
        //$paths[] = FileSystem::canonical(WIN_CURRENT_DIR . "\\" . $arg, "\\");
        $paths[] = canonical($arg, "\\");
        $paths[] = canonical(CURRENT_DIR . "\\" . $arg, "\\");

        foreach($paths as $path)
        {
            $real = str_replace([PROJECT_DIR, "\\"], [WORKING_DIR, "/"], $path);

            if (file_exists($real))
            {
                $arg = $real;
                break;
            }
        }
    }

    // NOTE: Do any other fix-ups here?

}

passthru("$command ".implode(" ", $prefix)." ".implode(" ", $argv)." ".implode(" ", $suffix));



// as per RFC 3986
// @see https://www.rfc-editor.org/rfc/rfc3986#section-5.2.4
function canonical(string $path, string $separator = DIRECTORY_SEPARATOR)
{
    // Force forward slashes!
    //$path = FileSystem::path($path, "/");
    $path = str_replace("\\", "/", $path);

    // 1.  The input buffer is initialized with the now-appended path
    //     components and the output buffer is initialized to the empty
    //     string.
    $output = '';

    // 2.  While the input buffer is not empty, loop as follows:
    while ($path !== '') {
        // A.  If the input buffer begins with a prefix of "`../`" or "`./`",
        //     then remove that prefix from the input buffer; otherwise,
        if (
            ($prefix = substr($path, 0, 3)) == '../' ||
            ($prefix = substr($path, 0, 2)) == './'
        ) {
            $path = substr($path, strlen($prefix));
        } else

            // B.  if the input buffer begins with a prefix of "`/./`" or "`/.`",
            //     where "`.`" is a complete path segment, then replace that
            //     prefix with "`/`" in the input buffer; otherwise,
            if (
                ($prefix = substr($path, 0, 3)) == '/./' ||
                ($prefix = $path) == '/.'
            ) {
                $path = '/' . substr($path, strlen($prefix));
            } else

                // C.  if the input buffer begins with a prefix of "/../" or "/..",
                //     where "`..`" is a complete path segment, then replace that
                //     prefix with "`/`" in the input buffer and remove the last
                //     segment and its preceding "/" (if any) from the output
                //     buffer; otherwise,
                if (
                    ($prefix = substr($path, 0, 4)) == '/../' ||
                    ($prefix = $path) == '/..'
                ) {
                    $path = '/' . substr($path, strlen($prefix));
                    $output = substr($output, 0, strpos($output, '/'));
                } else

                    // D.  if the input buffer consists only of "." or "..", then remove
                    //     that from the input buffer; otherwise,
                    if ($path == '.' || $path == '..') {
                        $path = '';
                    } else

                        // E.  move the first path segment in the input buffer to the end of
                        //     the output buffer, including the initial "/" character (if
                        //     any) and any subsequent characters up to, but not including,
                        //     the next "/" character or the end of the input buffer.
                    {
                        $pos = strpos($path, '/');
                        if ($pos === 0) $pos = strpos($path, '/', $pos+1);
                        if ($pos === false) $pos = strlen($path);
                        $output .= substr($path, 0, $pos);
                        $path = (string) substr($path, $pos);
                    }
    }

    // 3.  Finally, the output buffer is returned as the result of remove_dot_segments.
    return str_replace("/", $separator, $output);
}



function win2php(string $path): string
{
    return str_replace([PROJECT_DIR, "\\"], [WORKING_DIR,"/"], $path);
}



function php2win(string $path): string
{
    return str_replace([WORKING_DIR, "/"], [PROJECT_DIR, "\\"], $path);
}

